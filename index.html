<script>
  async function sendToServer() {
    const input = document.getElementById('userInput').value;
    const output = document.getElementById('outputText');
    const spinner = document.getElementById('spinner');
    const loadingText = document.getElementById('loadingText');

    spinner.style.display = 'inline-block';
    loadingText.style.display = 'block';
    output.innerHTML = "";

    try {
      const response = await fetch('https://nuyhsb.onrender.com/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: input }),
      });

      const data = await response.json();
      const reply = data.reply || "응답을 받을 수 없어요.";

      const emphasized = reply
        .replace(/힘들었어요/g, '<span class="highlight">힘들었어요</span>')
        .replace(/괜찮아/g, '<span class="highlight">괜찮아</span>')
        .replace(/고마워/g, '<span class="highlight">고마워</span>')
        .replace(/응원할게/g, '<span class="highlight">응원할게</span>')
        .replace(/행복해/g, '<span class="highlight">행복해</span>');

      spinner.style.display = 'none';
      loadingText.style.display = 'none';
      typeWriterHTML(emphasized, output);

    } catch (error) {
      spinner.style.display = 'none';
      loadingText.style.display = 'none';
      output.innerHTML = "오류가 발생했어요. 다시 시도해 주세요.";
    }
  }

  // HTML을 보존한 채로 출력하는 타자 애니메이션
  function typeWriterHTML(html, element) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;

    let queue = [];
    (function extractNodes(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        for (let char of node.textContent) {
          queue.push({ type: 'text', char });
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const startTag = `<${node.tagName.toLowerCase()} class="${node.className}">`;
        const endTag = `</${node.tagName.toLowerCase()}>`;

        queue.push({ type: 'html', content: startTag });
        for (let child of node.childNodes) {
          extractNodes(child);
        }
        queue.push({ type: 'html', content: endTag });
      }
    })(tempDiv);

    let i = 0;
    element.innerHTML = '';

    function type() {
      if (i >= queue.length) return;
      const part = queue[i++];
      element.innerHTML += part.type === 'text' ? part.char : part.content;
      setTimeout(type, 20);
    }

    type();
  }
</script>
